import Result from './result.js';
export declare const Variant: {
    readonly Just: "Just";
    readonly Nothing: "Nothing";
};
export declare type Variant = keyof typeof Variant;
export interface JustJSON<T> {
    variant: 'Just';
    value: T;
}
export interface NothingJSON {
    variant: 'Nothing';
}
export declare type MaybeJSON<T> = JustJSON<T> | NothingJSON;
declare class MaybeImpl<T> {
    private repr;
    constructor(value?: T | null | undefined);
    static of<T>(value: T | null | undefined): Maybe<T>;
    static just<T>(value?: T | null): Maybe<T>;
    static nothing<T>(_?: null): Nothing<T>;
    get variant(): Variant;
    get value(): T;
    get isJust(): boolean;
    get isNothing(): boolean;
    map<U>(this: Maybe<T>, mapFn: (t: T) => U): Maybe<U>;
    mapOr<U>(this: Maybe<T>, orU: U, mapFn: (t: T) => U): U;
    mapOrElse<U>(this: Maybe<T>, orElseFn: () => U, mapFn: (t: T) => U): U;
    match<U>(this: Maybe<T>, matcher: Matcher<T, U>): U;
    or(this: Maybe<T>, mOr: Maybe<T>): Maybe<T>;
    orElse(this: Maybe<T>, orElseFn: () => Maybe<T>): Maybe<T>;
    and<U>(this: Maybe<T>, mAnd: Maybe<U>): Maybe<U>;
    andThen<U>(this: Maybe<T>, andThenFn: (t: T) => Maybe<U>): Maybe<U>;
    unwrapOr<U>(this: Maybe<T>, defaultValue: U): T | U;
    unwrapOrElse<U>(this: Maybe<T>, elseFn: () => U): T | U;
    toOkOrErr<E>(this: Maybe<T>, error: E): Result<T, E>;
    toOkOrElseErr<E>(this: Maybe<T>, elseFn: () => E): Result<T, E>;
    toString(this: Maybe<T>): string;
    toJSON(this: Maybe<T>): MaybeJSON<unknown>;
    equals(this: Maybe<T>, comparison: Maybe<T>): boolean;
    ap<A, B>(this: Maybe<(val: A) => B>, val: Maybe<A>): Maybe<B>;
    get<K extends keyof T>(this: Maybe<T>, key: K): Maybe<NonNullable<T[K]>>;
}
export interface Just<T> extends MaybeImpl<T> {
    variant: 'Just';
    value: T;
    isJust: true;
    isNothing: false;
}
export interface Nothing<T> extends Pick<MaybeImpl<T>, Exclude<keyof MaybeImpl<T>, 'value'>> {
    readonly variant: 'Nothing';
    isJust: false;
    isNothing: true;
}
export declare const just: typeof MaybeImpl.just;
export declare const nothing: typeof MaybeImpl.nothing;
export declare const of: typeof MaybeImpl.of;
export declare function map<T, U>(mapFn: (t: T) => U): (maybe: Maybe<T>) => Maybe<U>;
export declare function map<T, U>(mapFn: (t: T) => U, maybe: Maybe<T>): Maybe<U>;
export declare function mapOr<T, U>(orU: U, mapFn: (t: T) => U, maybe: Maybe<T>): U;
export declare function mapOr<T, U>(orU: U, mapFn: (t: T) => U): (maybe: Maybe<T>) => U;
export declare function mapOr<T, U>(orU: U): (mapFn: (t: T) => U) => (maybe: Maybe<T>) => U;
export declare function mapOrElse<T, U>(orElseFn: () => U, mapFn: (t: T) => U, maybe: Maybe<T>): U;
export declare function mapOrElse<T, U>(orElseFn: () => U, mapFn: (t: T) => U): (maybe: Maybe<T>) => U;
export declare function mapOrElse<T, U>(orElseFn: () => U): (mapFn: (t: T) => U) => (maybe: Maybe<T>) => U;
export declare function and<T, U>(andMaybe: Maybe<U>, maybe: Maybe<T>): Maybe<U>;
export declare function and<T, U>(andMaybe: Maybe<U>): (maybe: Maybe<T>) => Maybe<U>;
export declare function andThen<T, U>(thenFn: (t: T) => Maybe<U>, maybe: Maybe<T>): Maybe<U>;
export declare function andThen<T, U>(thenFn: (t: T) => Maybe<U>): (maybe: Maybe<T>) => Maybe<U>;
export declare function or<T>(defaultMaybe: Maybe<T>, maybe: Maybe<T>): Maybe<T>;
export declare function or<T>(defaultMaybe: Maybe<T>): (maybe: Maybe<T>) => Maybe<T>;
export declare function orElse<T>(elseFn: () => Maybe<T>, maybe: Maybe<T>): Maybe<T>;
export declare function orElse<T>(elseFn: () => Maybe<T>): (maybe: Maybe<T>) => Maybe<T>;
export declare function unwrapOr<T, U>(defaultValue: U, maybe: Maybe<T>): T | U;
export declare function unwrapOr<T, U>(defaultValue: U): (maybe: Maybe<T>) => T | U;
export declare function unwrapOrElse<T, U>(orElseFn: () => U, maybe: Maybe<T>): T | U;
export declare function unwrapOrElse<T, U>(orElseFn: () => U): (maybe: Maybe<T>) => T | U;
export declare function fromResult<T>(result: Result<T, unknown>): Maybe<T>;
export declare function toString<T extends {
    toString(): string;
}>(maybe: Maybe<T>): string;
export declare function toJSON<T>(maybe: Maybe<T>): MaybeJSON<unknown>;
export declare type Matcher<T, A> = {
    Just: (value: T) => A;
    Nothing: () => A;
};
export declare function match<T, A>(matcher: Matcher<T, A>, maybe: Maybe<T>): A;
export declare function match<T, A>(matcher: Matcher<T, A>): (m: Maybe<T>) => A;
export declare function equals<T>(mb: Maybe<T>, ma: Maybe<T>): boolean;
export declare function equals<T>(mb: Maybe<T>): (ma: Maybe<T>) => boolean;
export declare function ap<T, U>(maybeFn: Maybe<(t: T) => U>, maybe: Maybe<T>): Maybe<U>;
export declare function ap<T, U>(maybeFn: Maybe<(t: T) => U>): (maybe: Maybe<T>) => Maybe<U>;
export declare function isInstance<T>(item: unknown): item is Maybe<T>;
export declare type Predicate<T> = (element: T, index: number, array: T[]) => boolean;
export declare function find<T>(predicate: Predicate<T>, array: T[]): Maybe<T>;
export declare function find<T>(predicate: Predicate<T>): (array: T[]) => Maybe<T>;
export declare function first<T>(array: Array<T | null | undefined>): Maybe<T>;
export declare const head: typeof first;
export declare function last<T>(array: Array<T | null | undefined>): Maybe<T>;
export declare function transposeArray<T extends Array<Maybe<unknown>>>(maybes: T): TransposedArray<T>;
export declare type Unwrapped<T> = T extends Maybe<infer U> ? U : T;
export declare type TransposedArray<T extends Array<Maybe<unknown>>> = Maybe<{
    [K in keyof T]: Unwrapped<T[K]>;
}>;
export declare const all: typeof transposeArray;
export declare const tuple: typeof transposeArray;
export declare function transposeResult<T, E>(result: Result<Maybe<T>, E>): Maybe<Result<T, E>>;
export declare function toOkOrErr<T, E>(error: E, maybe: Maybe<T>): Result<T, E>;
export declare function toOkOrErr<T, E>(error: E): (maybe: Maybe<T>) => Result<T, E>;
export declare function toOkOrElseErr<T, E>(elseFn: () => E, maybe: Maybe<T>): Result<T, E>;
export declare function toOkOrElseErr<T, E>(elseFn: () => E): (maybe: Maybe<T>) => Result<T, E>;
export declare function property<T, K extends keyof T>(key: K, obj: T): Maybe<NonNullable<T[K]>>;
export declare function property<T, K extends keyof T>(key: K): (obj: T) => Maybe<NonNullable<T[K]>>;
export declare function get<T, K extends keyof T>(key: K, maybeObj: Maybe<T>): Maybe<NonNullable<T[K]>>;
export declare function get<T, K extends keyof T>(key: K): (maybeObj: Maybe<T>) => Maybe<NonNullable<T[K]>>;
export declare function wrapReturn<F extends AnyFunction, P extends Parameters<F>, R extends NonNullable<ReturnType<F>>>(fn: F): (...args: P) => Maybe<R>;
export declare type AnyFunction = (...args: never[]) => unknown;
export interface MaybeConstructor {
    new <T>(value?: T | null | undefined): Maybe<T>;
    of: typeof MaybeImpl.of;
    just: typeof MaybeImpl.just;
    nothing: typeof MaybeImpl.nothing;
}
export declare type Maybe<T> = Just<T> | Nothing<T>;
export declare const Maybe: MaybeConstructor;
export default Maybe;
//# sourceMappingURL=maybe.d.ts.map