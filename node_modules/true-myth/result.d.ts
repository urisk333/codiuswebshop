import type Maybe from './maybe.js';
import Unit from './unit.js';
export declare const Variant: {
    readonly Ok: "Ok";
    readonly Err: "Err";
};
export declare type Variant = keyof typeof Variant;
export interface OkJSON<T> {
    variant: 'Ok';
    value: T;
}
export interface ErrJSON<E> {
    variant: 'Err';
    error: E;
}
export declare type ResultJSON<T, E> = OkJSON<T> | ErrJSON<E>;
declare class ResultImpl<T, E> {
    private repr;
    private constructor();
    static ok<T, E>(): Result<Unit, E>;
    static ok<T, E>(value: T): Result<T, E>;
    static err<T, E>(): Result<T, Unit>;
    static err<T, E>(error: E): Result<T, E>;
    get variant(): Variant;
    get value(): T | never;
    get error(): E | never;
    get isOk(): boolean;
    get isErr(): boolean;
    map<U>(this: Result<T, E>, mapFn: (t: T) => U): Result<U, E>;
    mapOr<U>(this: Result<T, E>, orU: U, mapFn: (t: T) => U): U;
    mapOrElse<U>(this: Result<T, E>, orElseFn: (err: E) => U, mapFn: (t: T) => U): U;
    match<U>(this: Result<T, E>, matcher: Matcher<T, E, U>): U;
    mapErr<F>(this: Result<T, E>, mapErrFn: (e: E) => F): Result<T, F>;
    or<F>(this: Result<T, E>, orResult: Result<T, F>): Result<T, F>;
    orElse<F>(this: Result<T, E>, orElseFn: (err: E) => Result<T, F>): Result<T, F>;
    and<U>(this: Result<T, E>, mAnd: Result<U, E>): Result<U, E>;
    andThen<U>(this: Result<T, E>, andThenFn: (t: T) => Result<U, E>): Result<U, E>;
    unwrapOr<U = T>(this: Result<T, E>, defaultValue: U): T | U;
    unwrapOrElse<U>(this: Result<T, E>, elseFn: (error: E) => U): T | U;
    toMaybe(this: Result<T, E>): Maybe<T>;
    toString(this: Result<T, E>): string;
    toJSON(this: Result<T, E>): ResultJSON<T, E>;
    equals(this: Result<T, E>, comparison: Result<T, E>): boolean;
    ap<A, B>(this: Result<(a: A) => B, E>, r: Result<A, E>): Result<B, E>;
}
export interface Ok<T, E> extends ResultImpl<T, E> {
    variant: 'Ok';
    isOk: true;
    isErr: false;
    value: T;
    error: never;
}
export interface Err<T, E> extends ResultImpl<T, E> {
    readonly variant: 'Err';
    isOk: false;
    isErr: true;
    value: never;
    error: E;
}
export declare function tryOr<T, E>(error: E, callback: () => T): Result<T, E>;
export declare function tryOr<T, E>(error: E): (callback: () => T) => Result<T, E>;
export declare const ok: typeof ResultImpl.ok;
export declare const err: typeof ResultImpl.err;
export declare function tryOrElse<T, E>(onError: (e: unknown) => E, callback: () => T): Result<T, E>;
export declare function tryOrElse<T, E>(onError: (e: unknown) => E): (callback: () => T) => Result<T, E>;
export declare function map<T, U, E>(mapFn: (t: T) => U, result: Result<T, E>): Result<U, E>;
export declare function map<T, U, E>(mapFn: (t: T) => U): (result: Result<T, E>) => Result<U, E>;
export declare function mapOr<T, U, E>(orU: U, mapFn: (t: T) => U, result: Result<T, E>): U;
export declare function mapOr<T, U, E>(orU: U, mapFn: (t: T) => U): (result: Result<T, E>) => U;
export declare function mapOr<T, U, E>(orU: U): (mapFn: (t: T) => U) => (result: Result<T, E>) => U;
export declare function mapOrElse<T, U, E>(orElseFn: (err: E) => U, mapFn: (t: T) => U, result: Result<T, E>): U;
export declare function mapOrElse<T, U, E>(orElseFn: (err: E) => U, mapFn: (t: T) => U): (result: Result<T, E>) => U;
export declare function mapOrElse<T, U, E>(orElseFn: (err: E) => U): (mapFn: (t: T) => U) => (result: Result<T, E>) => U;
export declare function mapErr<T, E, F>(mapErrFn: (e: E) => F, result: Result<T, E>): Result<T, F>;
export declare function mapErr<T, E, F>(mapErrFn: (e: E) => F): (result: Result<T, E>) => Result<T, F>;
export declare function and<T, U, E>(andResult: Result<U, E>, result: Result<T, E>): Result<U, E>;
export declare function and<T, U, E>(andResult: Result<U, E>): (result: Result<T, E>) => Result<U, E>;
export declare function andThen<T, U, E>(thenFn: (t: T) => Result<U, E>, result: Result<T, E>): Result<U, E>;
export declare function andThen<T, U, E>(thenFn: (t: T) => Result<U, E>): (result: Result<T, E>) => Result<U, E>;
export declare function or<T, E, F>(defaultResult: Result<T, F>, result: Result<T, E>): Result<T, F>;
export declare function or<T, E, F>(defaultResult: Result<T, F>): (result: Result<T, E>) => Result<T, F>;
export declare function orElse<T, E, F>(elseFn: (err: E) => Result<T, F>, result: Result<T, E>): Result<T, F>;
export declare function orElse<T, E, F>(elseFn: (err: E) => Result<T, F>): (result: Result<T, E>) => Result<T, F>;
export declare function unwrapOr<T, U, E>(defaultValue: U, result: Result<T, E>): U | T;
export declare function unwrapOr<T, U, E>(defaultValue: U): (result: Result<T, E>) => U | T;
export declare function unwrapOrElse<T, U, E>(orElseFn: (error: E) => U, result: Result<T, E>): T | U;
export declare function unwrapOrElse<T, U, E>(orElseFn: (error: E) => U): (result: Result<T, E>) => T | U;
export declare function fromMaybe<T, E>(errValue: E, maybe: Maybe<T>): Result<T, E>;
export declare function fromMaybe<T, E>(errValue: E): (maybe: Maybe<T>) => Result<T, E>;
export declare const toString: <T extends {
    toString(): string;
}, E extends {
    toString(): string;
}>(result: Result<T, E>) => string;
export declare const toJSON: <T, E>(result: Result<T, E>) => ResultJSON<T, E>;
export declare type Matcher<T, E, A> = {
    Ok: (value: T) => A;
    Err: (error: E) => A;
};
export declare function match<T, E, A>(matcher: Matcher<T, E, A>, result: Result<T, E>): A;
export declare function match<T, E, A>(matcher: Matcher<T, E, A>): (result: Result<T, E>) => A;
export declare function equals<T, E>(resultB: Result<T, E>, resultA: Result<T, E>): boolean;
export declare function equals<T, E>(resultB: Result<T, E>): (resultA: Result<T, E>) => boolean;
export declare function ap<T, U, E>(resultFn: Result<(t: T) => U, E>, result: Result<T, E>): Result<U, E>;
export declare function ap<T, U, E>(resultFn: Result<(t: T) => U, E>): (result: Result<T, E>) => Result<U, E>;
export declare function isInstance<T, E>(item: unknown): item is Result<T, E>;
export declare function transposeMaybe<T, E>(maybe: Maybe<Result<T, E>>): Result<Maybe<T>, E>;
export declare function toMaybe<T, E>(result: Result<T, E>): Maybe<T>;
export interface ResultConstructor {
    ok: typeof ResultImpl.ok;
    err: typeof ResultImpl.err;
}
export declare type Result<T, E> = Ok<T, E> | Err<T, E>;
export declare const Result: ResultConstructor;
export default Result;
//# sourceMappingURL=result.d.ts.map