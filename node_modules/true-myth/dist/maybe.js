import Result from './result.js';
import { curry1, isVoid } from './-private/utils.js';
import * as Toolbelt from './toolbelt.js';
export const Variant = {
    Just: 'Just',
    Nothing: 'Nothing',
};
let NOTHING;
class MaybeImpl {
    constructor(value) {
        if (isVoid(value)) {
            this.repr = [Variant.Nothing];
            if (!NOTHING) {
                NOTHING = this;
            }
            return NOTHING;
        }
        else {
            this.repr = [Variant.Just, value];
        }
    }
    static of(value) {
        return new MaybeImpl(value);
    }
    static just(value) {
        if (isVoid(value)) {
            throw new Error(`attempted to call "just" with ${value}`);
        }
        return new MaybeImpl(value);
    }
    static nothing(_) {
        return new MaybeImpl();
    }
    get variant() {
        return this.repr[0];
    }
    get value() {
        if (this.repr[0] === Variant.Nothing) {
            throw new Error('Cannot get the value of `Nothing`');
        }
        return this.repr[1];
    }
    get isJust() {
        return this.repr[0] === Variant.Just;
    }
    get isNothing() {
        return this.repr[0] === Variant.Nothing;
    }
    map(mapFn) {
        return map(mapFn, this);
    }
    mapOr(orU, mapFn) {
        return mapOr(orU, mapFn, this);
    }
    mapOrElse(orElseFn, mapFn) {
        return mapOrElse(orElseFn, mapFn, this);
    }
    match(matcher) {
        return match(matcher, this);
    }
    or(mOr) {
        return or(mOr, this);
    }
    orElse(orElseFn) {
        return orElse(orElseFn, this);
    }
    and(mAnd) {
        return and(mAnd, this);
    }
    andThen(andThenFn) {
        return andThen(andThenFn, this);
    }
    unwrapOr(defaultValue) {
        return unwrapOr(defaultValue, this);
    }
    unwrapOrElse(elseFn) {
        return unwrapOrElse(elseFn, this);
    }
    toOkOrErr(error) {
        return Toolbelt.toOkOrErr(error, this);
    }
    toOkOrElseErr(elseFn) {
        return Toolbelt.toOkOrElseErr(elseFn, this);
    }
    toString() {
        return toString(this);
    }
    toJSON() {
        return toJSON(this);
    }
    equals(comparison) {
        return equals(comparison, this);
    }
    ap(val) {
        return ap(this, val);
    }
    get(key) {
        return get(key, this);
    }
}
export const just = MaybeImpl.just;
export const nothing = MaybeImpl.nothing;
export const of = MaybeImpl.of;
export function map(mapFn, maybe) {
    const op = (m) => (m.isJust ? just(mapFn(m.value)) : nothing());
    return curry1(op, maybe);
}
export function mapOr(orU, mapFn, maybe) {
    function fullOp(fn, m) {
        return m.isJust ? fn(m.value) : orU;
    }
    function partialOp(fn, curriedMaybe) {
        return curriedMaybe !== undefined
            ? fullOp(fn, curriedMaybe)
            : (extraCurriedMaybe) => fullOp(fn, extraCurriedMaybe);
    }
    return mapFn === undefined
        ? partialOp
        : maybe === undefined
            ? partialOp(mapFn)
            : partialOp(mapFn, maybe);
}
export function mapOrElse(orElseFn, mapFn, maybe) {
    function fullOp(fn, m) {
        return m.isJust ? fn(m.value) : orElseFn();
    }
    function partialOp(fn, curriedMaybe) {
        return curriedMaybe !== undefined
            ? fullOp(fn, curriedMaybe)
            : (extraCurriedMaybe) => fullOp(fn, extraCurriedMaybe);
    }
    if (mapFn === undefined) {
        return partialOp;
    }
    else if (maybe === undefined) {
        return partialOp(mapFn);
    }
    else {
        return partialOp(mapFn, maybe);
    }
}
export function and(andMaybe, maybe) {
    const op = (m) => (m.isJust ? andMaybe : nothing());
    return curry1(op, maybe);
}
export function andThen(thenFn, maybe) {
    const op = (m) => (m.isJust ? thenFn(m.value) : nothing());
    return maybe !== undefined ? op(maybe) : op;
}
export function or(defaultMaybe, maybe) {
    const op = (m) => (m.isJust ? m : defaultMaybe);
    return maybe !== undefined ? op(maybe) : op;
}
export function orElse(elseFn, maybe) {
    const op = (m) => (m.isJust ? m : elseFn());
    return curry1(op, maybe);
}
export function unwrapOr(defaultValue, maybe) {
    const op = (m) => (m.isJust ? m.value : defaultValue);
    return curry1(op, maybe);
}
export function unwrapOrElse(orElseFn, maybe) {
    const op = (m) => (m.isJust ? m.value : orElseFn());
    return curry1(op, maybe);
}
export function fromResult(result) {
    return Toolbelt.fromResult(result);
}
export function toString(maybe) {
    const body = maybe.isJust ? `(${maybe.value.toString()})` : '';
    return `${maybe.variant}${body}`;
}
export function toJSON(maybe) {
    return maybe.isJust
        ? {
            variant: maybe.variant,
            value: isInstance(maybe.value) ? maybe.value.toJSON() : maybe.value,
        }
        : { variant: maybe.variant };
}
export function match(matcher, maybe) {
    const op = (curriedMaybe) => mapOrElse(matcher.Nothing, matcher.Just, curriedMaybe);
    return curry1(op, maybe);
}
export function equals(mb, ma) {
    const op = (maybeA) => maybeA.match({
        Just: (aVal) => mb.isJust && mb.value === aVal,
        Nothing: () => mb.isNothing,
    });
    return curry1(op, ma);
}
export function ap(maybeFn, maybe) {
    const op = (m) => m.andThen((val) => maybeFn.map((fn) => fn(val)));
    return curry1(op, maybe);
}
export function isInstance(item) {
    return item instanceof Maybe;
}
export function find(predicate, array) {
    const op = (a) => Maybe.of(a.find(predicate));
    return curry1(op, array);
}
export function first(array) {
    return Maybe.of(array[0]);
}
export const head = first;
export function last(array) {
    return Maybe.of(array[array.length - 1]);
}
export function transposeArray(maybes) {
    return maybes.reduce((acc, m) => acc.andThen((ms) => m.map((m) => [...ms, m])), just([]));
}
export const all = transposeArray;
export const tuple = transposeArray;
export function transposeResult(result) {
    return Toolbelt.transposeResult(result);
}
export function toOkOrErr(error, maybe) {
    const op = (m) => (m.isJust ? Result.ok(m.value) : Result.err(error));
    return maybe !== undefined ? op(maybe) : op;
}
export function toOkOrElseErr(elseFn, maybe) {
    const op = (m) => (m.isJust ? Result.ok(m.value) : Result.err(elseFn()));
    return curry1(op, maybe);
}
export function property(key, obj) {
    const op = (a) => Maybe.of(a[key]);
    return curry1(op, obj);
}
export function get(key, maybeObj) {
    return curry1(andThen(property(key)), maybeObj);
}
export function wrapReturn(fn) {
    return (...args) => Maybe.of(fn(...args));
}
export const Maybe = MaybeImpl;
export default Maybe;
//# sourceMappingURL=maybe.js.map